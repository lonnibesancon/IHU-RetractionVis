<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3.js Stacked Bar Chart with Status Legend</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      flex-direction: column;
    }

    #general-box {
      width: 100%;
      display: flex;
      flex-direction: column;
    }

    #interaction-info-container {
      display: flex;
    }

    #interaction-box {
      width: 60%;
    }

    #info-box {
      width: 40%;
    }

    #graph-container {
      margin-top: 20px;
    }

    #chart {
      display: inline-block;
      position: relative;
      width: 100%;
    }

    .legend {
      display: flex;
      justify-content: center;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-right: 20px;
    }

    .legend-item__color {
      width: 20px;
      height: 20px;
      margin-right: 5px;
    }
  </style>
  <!-- Include D3.js library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
  <div id="general-box">
    <div id="interaction-info-container">
      <div id="interaction-box">
        <p>This is the infobox - This is the infobox - This is the infobox</p>
        <p>This is the infobox - This is the infobox - This is the infobox</p>
      </div>
      <div>
        <div id="grouped-checkbox-container">
          <input type="checkbox" id="grouped-checkbox">
          <label for="grouped-checkbox">Grouped</label>
          <p>IRB Number:<select id="IRBNumberSelect">
              <!-- Options will be added dynamically using D3.js -->
          </select></p>
        </div>
      </div>
      <div id="info-box">
        <table id="info-table">
          <tbody>
            <tr>
              <td>DOI:</td>
              <td id="DOI"></td>
            </tr>
            <tr>
              <td>Title</td>
              <td id="Title"></td>
            </tr>
            <tr>
              <td>Journal Name</td>
              <td id="Journal_Name"></td>
            </tr>
            <tr>
              <td>Status</td>
              <td id="Status"></td>
            </tr>
            <tr>
              <td>Citations</td>
              <td id="Citations"></td>
            </tr>
            <tr>
              <td>IRB Number</td>
              <td id="IRB_Number"></td>
            </tr>
            <tr>
              <td>Link to Status Update</td>
              <td id="DOI_Status"></td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
  <div id="graph-container">
    <svg id="chart"></svg>
    <div class="legend" id="legend"></div>
  </div>

  <script>
    // Google Spreadsheet URL
    const spreadsheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSZMRkkQWNEz6zzcOaI3PwJohV6rqS6cYl5rTJm0LrQb9hthouOMdf4YfuDXr2bDgny9F7fHjSo9S8J/pub?output=csv';

    // Define colors for each status
    const statusColors = {
      'N/A': "#303bc9",
      'Retraction': '#e02d19',
      'EoC': '#fab0a7'
    };

    // Fetch the data from the Google Spreadsheet
    d3.csv(spreadsheetUrl).then(data => {
      // Sort the data by Journal_Name and then by Status
      data.sort((a, b) => {
        // Define the desired order
        const order = ['N/A', 'EoC', 'Retraction'];
        
        // Get the index of status in the desired order
        const statusIndexA = order.indexOf(a.Status);
        const statusIndexB = order.indexOf(b.Status);

        // If the statuses are different, sort by status index
        if (statusIndexA !== statusIndexB) {
          return statusIndexA - statusIndexB;
        } else {
          // If the statuses are the same, sort by Journal_Name
          return a.Journal_Name.localeCompare(b.Journal_Name);
        }
      });

      // Group data by Journal_Name
      const groupedData = d3.group(data, d => d.Journal_Name);

      // Sort groupedData by total count in increasing order
      const sortedGroupedData = Array.from(groupedData.entries()).sort((a, b) => b[1].length - a[1].length);

      // Calculate maximum count for x axis
      const maxCount = d3.max(sortedGroupedData, d => d[1].length);

      // D3.js code for visualization
      const margin = { top: 20, right: 20, bottom: 50, left: 100 };
      const width = 800 - margin.left - margin.right;
      const height = 400 - margin.top - margin.bottom;

      const svg = d3.select("#chart")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // Define scales using sorted data
      const xScale = d3.scaleLinear()
        .domain([0, maxCount+1])
        .range([0, width]);

      const yScale = d3.scaleBand()
        .range([0, height])
        .padding(0.1);

      // Set yScale domain after data is loaded
      yScale.domain(sortedGroupedData.map(d => d[0]));

      const citationScale = d3.scaleLinear()
        .domain([0, d3.max(data, d => parseFloat(d.Citations))])
        .range([5, yScale.bandwidth()/2]);

      // Draw x-axis
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(xScale));

      // Draw y-axis
      const yAxis = svg.append("g")
        .call(d3.axisLeft(yScale).tickSize(0));

      yAxis.selectAll(".tick text")
        .call(wrap, margin.left - 10);

      let filteredData = sortedGroupedData; // Initialize filteredData with all data

      // Create a dropdown menu or selection field in your HTML
      const selectIRBNumber = d3.select("#IRBNumberSelect")
        .on("change", function() {
          console.log("-------------------")
          console.log("SORTING STARTED")
          console.log("sortedGroupedData")
          console.dir(sortedGroupedData)
          const selectedIRBNumber = this.value; // Get the selected IRB_Number value
          if (selectedIRBNumber === "All") {
            filteredData = sortedGroupedData; // Show all data
          } else {
            filteredData = sortedGroupedData.map(group => {
              const filteredItems = group[1].filter(item => {
                console.log("Checking IRB_Number:", item.IRB_Number);
                console.log("Selected IRB_Number:", selectedIRBNumber);

                // Convert to strings if they are not already
                const itemIRB = String(item.IRB_Number);
                const selectedIRB = String(selectedIRBNumber);

                if (itemIRB !== item.IRB_Number) {
                  console.log("Converted IRB_Number to string:", itemIRB);
                }

                if (selectedIRB !== selectedIRBNumber) {
                  console.log("Converted selectedIRBNumber to string:", selectedIRB);
                }

                return itemIRB === selectedIRB; // Compare as strings
              });

              return [group[0], filteredItems]; // Return group with filtered items
            });
          }
          updateVisualization();
          console.log("filteredData")
          console.dir(filteredData)
          console.log("SORTING FINISHED")
          console.log("-------------------")
        });

      // Add an option for "All" IRB_Numbers
      selectIRBNumber.append("option").text("All").attr("value", "All");

      // Add options for each unique IRB_Number
      const uniqueIRBNumbers = Array.from(new Set(data.map(d => d.IRB_Number)));
      uniqueIRBNumbers.forEach(number => {
        selectIRBNumber.append("option").text(number).attr("value", number);
      });

      // Add legend
      const legend = d3.select("#legend");

      Object.entries(statusColors).forEach(([status, color]) => {
        const legendItem = legend.append("div").attr("class", "legend-item");
        legendItem.append("div")
          .attr("class", "legend-item__color")
          .style("background-color", color);
        legendItem.append("span").text(status);
      });
function updateVisualization() {
    // Update yScale domain based on filteredData
    yScale.domain(filteredData.map(d => d[0]));

    // Select and update existing bars
    const barGroups = svg.selectAll(".bar-group")
        .data(filteredData, d => d[0]);

    barGroups.exit()
        .transition()
        .duration(500)
        .remove(); // Remove bars for data that no longer exists

    const enterBars = barGroups.enter()
        .append("g")
        .attr("class", "bar-group");

    // Calculate citation radius
    const maxRadius = yScale.bandwidth() / 2; // Maximum radius is half of the space available for each bar
    const citationScale = d3.scaleLinear()
        .domain([0, d3.max(filteredData.flatMap(d => d[1]), d => parseFloat(d.Citations))])
        .range([5, maxRadius]);

    // For circle-citation
    const circlesCitation = enterBars.merge(barGroups)
        .selectAll(".circle-citation")
        .data(d => d[1]);

    circlesCitation.exit()
        .transition()
        .duration(500)
        .attr("r", 0)
        .remove(); // Remove circles for data that no longer exists

    circlesCitation.enter()
        .append("circle")
        .attr("class", "circle-citation")
        .attr("r", 0) // Set initial radius to 0 for smooth transition
        .merge(circlesCitation)
        .transition()
        .duration(500)
        .attr("cx", (d, i) => xScale(i + 1)) // Use the index to determine x position
        .attr("cy", d => yScale(d.Journal_Name) + yScale.bandwidth() / 2) // Use Journal_Name for y position
        .attr("r", d => citationScale(parseFloat(d.Citations)))
        .attr("fill", d => d3.color(statusColors[d.Status]).brighter(0.5))
        .attr("fill-opacity", 0.3)
        .attr("original-fill", d => statusColors[d.Status])
        .style("pointer-events", "none");

    // For circle-point
    const circlesPoint = enterBars.merge(barGroups)
        .selectAll(".circle-point")
        .data(d => d[1]);

    circlesPoint.exit()
        .transition()
        .duration(500)
        .attr("r", 0)
        .remove(); // Remove circles for data that no longer exists

    circlesPoint.enter()
        .append("circle")
        .attr("class", "circle-point")
        .attr("r", 0) // Set initial radius to 0 for smooth transition
        .merge(circlesPoint)
        .transition()
        .duration(500)
        .attr("cx", (d, i) => xScale(i + 1)) // Use the index to determine x position
        .attr("cy", d => yScale(d.Journal_Name) + yScale.bandwidth() / 2) // Use Journal_Name for y position
        .attr("r", 5)
        .attr("fill", d => statusColors[d.Status])
        .attr("original-fill", d => statusColors[d.Status]);
}

      updateVisualization(); // Draw initial visualization

    }).catch(error => {
      console.error('Error fetching the data:', error);
    });

    function wrap(text, width) {
      text.each(function() {
        var text = d3.select(this),
          words = text.text().split(/\s+/).reverse(),
          word,
          line = [],
          lineNumber = 0,
          lineHeight = 1.1, // ems
          y = text.attr("y"),
          dy = parseFloat(text.attr("dy") || 0),
          tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }
  </script>
</body>
</html>
